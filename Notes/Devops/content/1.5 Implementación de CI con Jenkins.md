## 1.5 Implementación de CI con Jenkins

Para ello es necesario instalar ambos paquetes.

Dado que docker solo se puede usar por root, es necesario dotarle de los
permisos.

``` bash
usermod -a -G docker jenkins
```

Montamos un pipeline multibranch en Jenkins, para tener todo el proceso
de manera **centralizada**.

Tip: Recuerda que es buena práctica colocar un timeout, para que el código
falle si demora demasiado.


``` bash
pipeline {
    agent any

    options {
        timeout(time: 2, unit: 'MINUTES')
    }

    environment {
        ARTIFACT_ID = "usuario/app:${env.BUILD_NUMBER}"
    }

    stages {
        stage('Build') {
        steps {
            script {
            dir("webapp") {
                dockerImage = docker.build "${env.ARTIFACT_ID}"
            }
            }
        }
        }
        stage('Run tests') {
            steps {
                sh "docker run ${dockerImage.id} npm test"
            }
        }
        stage('Publish') {
            when {
                branch 'master'
            }
        steps {
            script {
            docker.withRegistry("", "DockerHubCredentials") {
                dockerImage.push()
            }
            }
        }
        }
        stage('Schedule Staging Deployment') {
        when {
            branch 'master'
        }
        steps {
            build job: 'deploy-webapp-staging', parameters: [string(name: 'ARTIFACT_ID', value: "${env.ARTIFACT_ID}")], wait: false
        }
        }
    }
    }
```

La diferencia entre "docker.build" y "docker run" es que docker.build se
corre nativamente en Jenkins, en el background, mientras que "docker
run" corre a través del shell, para que nos avise si falla.

Una vez hecho, ejecutamos el job y podemos corroborar que todo se
ejecutó de manera perfecta.

