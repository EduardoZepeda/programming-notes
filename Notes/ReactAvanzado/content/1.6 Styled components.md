## 1.6 Styled components

Librería que nos permite estilar de forma muy sencilla, siguiendo CSS y
usando los tags de HTML que queramos usar en nuestra aplicación y
cualquier componente que acepte una prop className.

Se encarga de evitar colisiones de nombres y te permite colocar el css
directamente en el archivo js o ts. Así como el renderizado condicional
de CSS

``` bash
npm i styled-components
```

Para crear un estilo usaremos la siguiente sintaxis

``` javascript
import styled from 'styled-components'

export const Anchor = styled.a``
    display: flex;
    text-align: center;
    text-decoration: none;
    flex-direction: column;
    width: 75px;
``
```

Estos estilos pueden usarse directamente en los archivos o exportarse
como componentes para usar en nuestros archivos

``` html
<Anchor href="#"/>
```

Styled componentes también acepta componentes como argumento.

``` javascript
import styled from 'styled-components'
import { Link } from '@reach/router'

export const Anchor = styled(Link)``
``
```

### 1.6.1 Estilos globales

Creamos un archivo globalStyles

````` javascript
import { createGlobalStyle } from 'styled-components'

export const GlobalStyle = createGlobalStyle````
    html {
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }
````
`````

Después importamos ese archivo y lo colocamos en el nivel superior de la
app, en el componente APP en este ejemplo.

``` javascript
import { GlobalStyles } from './GlobalStyles'

export const App = () => (
  <>
    <GlobalStyles />
    <MainComponent/>
  </>
)
```

### 1.6.2 Creando animaciones

Podemos crear animaciones reutilizables usando keyframes directamente de
la librería de styled-components.

``` javascript
import {keyframes, css} from 'styled-components'

export const fadeIn = ({time = '1s', type='ease'} = {}) => css``
    animation: ${time} ${fadeInKeyframes} ${type};
``

const fadeInKeyframes = keyframes``
    from {
        filter: blur(5px);
        opacity:0;
    }
    to {
        filter: blur(0px);
        opacity:1;
    }

``
```

Una vez creadas podemos usarlas en los estilos de nuestros componentes

``` javascript
export const Img = styled.img``
    ${fadeIn()}
    box-shadow: 0 10px 14px rgba(0,0,0,0.2);
``
```

## 1.7 Hooks

Para ver los hooks principales revisa los apuntes de React básico.

### 1.7.1 useRef

El hook useRef nos permite guardar una referencia, esta referencia puede
ser a cualquier elemento.

#### 1.7.1.1 useRef al componente

useRef nos permite capturar la referencia al elemento en el DOM. Ref no
hace referencia al elemento en el cual se crea, sino a aquel que se lo
colocamos como un prop.

``` javascript
import {useRef} from 'react'

const Component = () => {
    const ref = useRef(null)
}
```

Por ejemplo, la variable ref contendrá una referencia a la etiqueta
article.

``` javascript
import {useRef} from 'react'

const Component = () => {
    const ref = useRef(null)
    return (<article ref={ref}>...<article/>)
}
```

Y para acceder directamente a la etiqueta necesitamos llamar a la
propiedad current de la referencia.

``` javascript
haz_algo(ref.current)
```

#### 1.7.1.2 UseRef al estado

También podemos referenciar un estado de React. Esto es bastante útil al
mezclarlo con useEffect en ocasiones donde queremos asignar un callback,
pero el estado (state) aún se encuentrará vacio.

Por ejemplo:

``` javascript
useEffect(()=> {
 // fetch data and set state
 socket.onmessage = (event) => {
      const messageJson = JSON.parse(event.data)
      // si realizamos esto dentro de un useEffect
      setState([messageJson.payload, ...state])
      }
   }
})
```

El estado (state) va a estar vacio y el callback se creará con el estado
vacio, dejándonos con un estado vacio.

En cambio, si guardamos una referencia usando un doble useEffect,
podemos guardar el nuevo estado en nuestra referencia usando un
useEffect que solo se ejecutará cuando cambie nuestra información (en
este caso data).

``` javascript
useEffect(()=>{
  // this sets a reference to posts and saves it in current
  stateRef.current = data
}, [data])

useEffect(()=>{
    // fetch data
    socket.onmessage = (event) => {
          const messageJson = JSON.parse(event.data)
          // si realizamos esto dentro de un useEffect
          setState([messageJson.payload, ...stateRef.current])
       }
    }
 }
```

Usando este acomodo podemos crear un callback que funcionará de manera
correcta usando la referencia que hemos creado hacia el estado.

### 1.7.2 Context

Context nos permite acceder a datos sin usar las Props por medio de un
contexto global.

Para usarlo necesitamos importar el createContext de React

El Context nos va a proporcionar 2 componentes:

-   Provider: componente que debe envolver a nuestra aplicación.
-   Consumer: nos va a permitir acceder a las render props que
    declaremos en el Provider.

``` javascript
import { createContext } from 'react'

export const Context = createContext()
```

Luego usaremos ese componente para envolver nuestra aplicación

``` javascript
ReactDOM.render(<Context.Provider value={{isAuth: true}}><App /></Context.Provider>, document.getElementById('app'))
```

Y envolveremos el componente que querramos que tenga acceso al contexto
que creamos.

``` javascript
<Context.Consumer>
  {
        ({ isAuth }) => isAuth
          ? <Router>
            <UserProfile path='/user' />
          </Router>
          : <Router>
            <LoginScreen path='/user' />
          </Router>
                  }
</Context.Consumer>
```

### 1.7.3 Custom hooks

Sirven para poder reutilizar la lógica en diferentes componentes. Para
poder utilizarlos, deben empezar por la palabra use (useMiNombreDeHook).
Los custom hooks pueden usar otros hooks incluso, otros custom hooks.

##### 1.7.3.1.1 Intersection observer

Un uso común del intersection observer es revisar si el elemento
referenciado está en el viewport del usuario. En la función useEffect de
abajo, creamos un observador y le pedimos que observe el elemento que
estamos referenciando, en este caso ref.current. Podemos ver el estado
directamente en las propiedades de entries

``` javascript
useEffect(()=>{
  const observer = new window.IntersectionObserver((entries)=>{
  const { isIntersecting } = entries[0]
  if(isIntersecting){
    setShow(true)
    observer.disconnect()
  }
  })
  observer.observe(ref.current)
}, [ref])
```

Hay que recordar un par de cosas. La primera es que, para que pueda
seguirse detectando el elemento con ref, es necesario devolver un
componente con el prop ref. Es decir, no podemos ejecutar ternarias u
operadores && para condicionar la renderización de componentes. La
segunda es que si un elemento no tiene una altura, todos van a estar en
el viewport al cargar la página. Por lo anterior es bueno dotar de
height o min-height a los elementos a observar.

``` javascript
//Si show es false ya no va a existir ref
show && <article ref={ref}>...<article/>

//Podemos reemplazarlo por
<article ref={ref}>{show&&<contenido/>}<article/>
```

## 1.8 RenderProps

Es una técnica para compartir código entre componentes en React que
utiliza una prop (cómo children u otra de otro nombre, aunque
normalmente se usa render) como función, que recibe como parámetro
información y devuelve el componente que queremos que renderice.

``` javascript
<DataProvider render={data => (
  <h1>Hello {data.target}</h1>
)}/>
```

También funciona con children

``` javascript
<Mouse children={mouse => (
  <p>The mouse position is {mouse.x}, {mouse.y}</p>
)}/>
```

Ya sea pasándole el parmáetro children como prop o directamente
colocándolo como un children

``` javascript
<Mouse>
  {mouse => (
    <p>The mouse position is {mouse.x}, {mouse.y}</p>
  )}
</Mouse>
```

## 1.9 Graphql

GraphQL es un lenguaje creado por Facebook para obtener solo los datos
que necesitamos.

React Apollo es un cliente que nos va a permitir conectarnos a un
servidor GraphQL.

``` javascript
npm install @apollo/client graphql
```

En nuestro archivo donde renderizamos con ReactDOM.render() importamos
las librerias necesarias, y creamos una constante cliente, la cual va a
contener el endpoint de nuestro graphql. Posteriormente, envolvemos el
componente de nuestra aplicación en el component ApolloProvider,
pasándole como un prop llamado client, la constante que acabamos de
crear.

``` javascript
import React from 'react'
import ReactDOM from 'react-dom'
import { App } from './App'
import { ApolloClient, ApolloProvider, InMemoryCache } from "@apollo/client";

const client = new ApolloClient({
  uri: "https://react-avanzado-testing-eduardozepeda.vercel.app/graphql/",
  cache: new InMemoryCache(),
});

ReactDOM.render(<ApolloProvider client={client}><App /></ApolloProvider>, document.getElementById('app'))
```

Ahora para usarlo, importamos las funciones requerias de @apollo/client
y creamos las consultas

``` javascript
import { useQuery, gql } from "@apollo/client"

const withPhotos = gql``
  query getPhotos {
    photos {
      id
      categoryId
      src
      likes
      userId
      liked
    }
  }
``
```

Ahora podemos usar la functión useQuery para obtener los datos

``` javascript
const { loading, error, data } = useQuery(whitPhotos);
```

### 1.9.1 Parámetros con graphql

Las queries tambien pueden recibir parámetros

``` javascript
const withPhotos = gql``
  query getPhotos($categoryId:ID) {
    photos(categoryId: $categoryId) {
      id
      categoryId
      src
      likes
      userId
      liked
    }
  }
``
```

Para que detecte los queries deberemos pasárselos dentro de la propiedad
variables del objeto que le pasaremos a la función useQuery como segundo
parámetro.

``` javascript
const { loading, error, data } = useQuery(withPhotos, { variables: { categoryId } });
```

### 1.9.2 Mutaciones

Las mutaciones nos permiten modificar datos y darles seguimiento.
Además, al igual que con useQuery, el hook de las mutaciones nos
devuelve el estado de error o carga de nuestra petición

``` javascript
import { gql, useMutation } from '@apollo/client'

const REGISTER = gql``
    mutation signup($input: UserCredentials!){
        signup(input: $input)
    }
``
export const useRegisterMutation = (email,password) => {
  const [registerMutation, { loading: mutationLoading, error: mutationError }] = useMutation(REGISTER, {variables: {input:{email, password}}})
  return { registerMutation, mutationLoading, mutationError }
}
```

## 1.10 React router

Reach Router es una versión simplificada y mejor optimizada de React
Router, su creador es Ryan Florence el mismo creador de React Router. Se
anunció que los dos paquetes se iban a unir, pero su API se va a parecer
más a Reach Router.

Al momento de escribir este apunte se instala así

``` javascript
npm i @reach/router
```

Y su uso es más simple que React/router. Aquí podemos indicarle la path
en la que se renderizará un componente directamente en el componente.
También cuenta con un componente redirect que redirige de una ruta a
otra.

``` javascript
<Router>
    <Home path='/'/>
    <Home path='/pet/:id'/>
    {!isAuth && <Redirect from='/favs' to='/login' />}
</Router>
```

Debemos cambiar la configuración de webpack

``` javascript
output: {
  filename: 'app.bundle.js',
  publicPath: '/'
},
```

Y el script de package.json que corre el servidor de desarrollo

``` javascript
"dev": "webpack serve --history-api-fallback",
```

### 1.10.1 Componente Link

Funciona igual que el de react router

``` javascript
import { Link } from '@reach/router'

<Link to={path}>

</Link>
```

##### 1.10.1.1.1 Obtener la página activa

@reach/router le añade el atributo aria-current="page" al componente
Link activo. Lo que nos permite darle estilos directamente buscando la
propiedad del componente y aplicandole estilos condicionales.

### 1.10.2 Renderizado condicional de rutas

Renderizar rutas de acuerdo a parametros tales como el estado de loggeo
se hace creando un componente que envolverá a otros componentes. En este
caso el componente UserLogged regresa el children y le pasa como
paramétro un objeto con isAuth.

``` javascript
const UserLogged = ({ children }) => {
  return children({ isAuth: false })
}
```

Nos asegurarnos de definir a children como una función, que reciba
parámetros y que retorne componentes. Usaremos el resultado del
parámetro creado para renderizar nuestros componentes envueltos en el
mismo objeto Router, como si se tratara de un router adicional al
principal.

``` javascript
<UserLogged>
  {
        ({ isAuth }) => isAuth
          ? <Router>
            <UserProfile path='/user' />
          </Router>
          : <Router>
            <LoginScreen path='/user' />
          </Router>
                  }
</UserLogged>
```

También es posible user el contexto para tener un código más ordenado

``` javascript
import React, {useContext} from 'react'
import Context from './Context'

const {isAuth} = useContext(Context)
<Router>
    {!isAuth && <Redirect from='/favs' to='/login' />}
</Router>
```

### 1.10.3 Páginas 404

React router puede especificar una página como default si no se
encuentra ninguna ruta colocandole un prop que diga default.

``` javascript
import { PageNotFound } from './pages/PageNotFound'

    <Router>
        <PageNotFound default/>
    </Router>
```

## 1.11 React Helmet

Helmet nos permite reemplazar el title y colocar cualquier otro
contenido dentro de la etiqueta head. Para usarlo primero hay que
instalarlo desde

``` javascript
npm i react-helmet
```

Una vez instalado podemos usarlo colocándole el contenido que querramos
en el archivo que querramos.

``` javascript
import { Helmet } from 'react-helmet'

export default Component = () => {
return (
<>
  <Helmet>
    {title && <title>Petgram | {title}</title>}
    {description && <meta name='description' content={description} />}
  </Helmet>
  <OtrosComponentes/>
</>
)
}
```

React helmet es muy versátil. Incluso podemos crear subcomponentes que
incluyan a Helmet y modifiquen su comportamiento

``` javascript
import { Helmet } from 'react-helmet'

export const Layout = ({ children, title, description, showTitle = false, showDescription = false }) => {
  return (
    <>
      <Helmet>
        {title && <title>Petgram | {title}</title>}
        {description && <meta name='description' content={description} />}
      </Helmet>
      <div>
        {(title && showTitle) && <h1>{title}</h1>}
        {(description && showDescription) && <div>{description}</div>}
        {children}
      </div>
    </>
  )
}
```

## 1.12 React Lazy

React lazy se encarga de importar de manera dinámica los componentes
como se van necesitando. Para lograrlo necesitamos pasarle a la función
React.lazy, como parámetro, una función que devuelva un import.

``` javascript
const Favs = React.lazy(() => import('./pages/Favs')) // Recuerda que el import lleva paréntesis, ya que es una función

export const App = () => {
    return(
    <Router>
        <Favs path='/favs' />
    </Router>
    )
}
```

Otro requisito consiste en que el componente a importar debe estar
exportado como default.

``` javascript
export default () => {...}
```

Además necesita estar envuelto en un componente Suspense, que recibirá
un prop llamado fallback. Fallback se refiere al componente que
renderizará mientras se cargar el import dinámico.

``` javascript
import React, { useContext, Suspense } from 'react'
import { Spinner } from './components/Spinner'

<Suspense fallback={<Spinner/>}>
    <Router>
        <Favs path='/favs' />
    </Router>
</Suspense>
```

Si todo funcionó correctamente podrás ver que al acceder al componente,
este realiza una petición al código que necesita para renderizarse. De
esta manera, se reduce el tamaño del bundle principal y el resto del
código se va cargando conforme se necesite.

## 1.13 PropTypes

Solia ser parte de React, pero fue separada. Es bastante similar al
tipado que ofrece Typescript.

``` javascript
npm i prop-types --save-dev
```

Ahora podemos verificar las props que recibe un componente creando un
objeto

``` javascript
import { PropTypes } from 'prop-types'

SingleComponent.propTypes = {
  liked: PropTypes.bool.isRequired,
  likes: PropTypes.number.isRequired,
  onClick: PropTypes.func.isRequired,
  disabled: PropTypes.bool
}
```

Podemos especificar si es un prop requerido agregando isRequired al tipo
de dato

De la misma manera que especificabamos el tipo, podemos establecer la
forma de los subtipos de datos que contiene una estructura, como el caso
de los arrays

``` javascript
ListOfSomethingComponent.propTypes = {
  favs: PropTypes.arrayOf(
    PropTypes.shape({
      id: PropTypes.string,
      src: PropTypes.string
    }))
}
```

### 1.13.1 Node es un proptype que se refiere a componentes de React

Hay ciertos componentes que reciben como prop un componente. En este
caso el tipo de dato será node, que se refiere a cualquier cosa que
React pueda renderizar.

``` javascript
import React from 'react'
import { Button } from './styles'
import { PropTypes } from 'prop-types'


export const SubmitButton = ({ children, disabled, onClick }) => {
  return <Button disabled={disabled} onClick={onClick}>{children}</Button>
}

SubmitButton.propTypes = {
  children: PropTypes.node.isRequired,
  onClick: PropTypes.func.isRequired,
  disabled: PropTypes.bool
}
```

### 1.13.2 PropTypes personalizados

También podemos crear validaciones de props personalizadas, para
componentes más complejos. Creando una función que recibe los props, el
nombre del Prop (propName) y el nombre del componente (componentName).
Podemos asignarle validación propia haciendo que retorne un objeto Error
con nuestra propia descripción

``` javascript
import { PropTypes } from 'prop-types'

PhotoCard.propTypes = {
  id: PropTypes.string.isRequired,
  liked: PropTypes.bool.isRequired,
  src: PropTypes.string.isRequired,
  likes: function (props, propName, componentName) {
    const propValue = props[propName]
    if (propValue == undefined){
      return new Error(``${propName} value must be defined``)
    }

    if (propValue<0){
      return new Error(``${propName} value must be greater than zero``)
    }
  }
}
```

## 1.14 PWA

``` javascript
npm i webpack-pwa-manifest --save-dev
```

Para usarlo necesitamos agregarlo al archivo de configuraciónd de React

``` javascript
const WebpackPwaManifest = require('webpack-pwa-manifest')
```

Ahora agregaremos un objeto nuevo en la sección de plugins de
*webpack.config.js*. El array sizes creará iconos para cada una de los
tamaños especificados. Asegúrate de tener un archivo en la ruta
especificada o dará error.

``` javascript
plugins: [
    new WebpackPwaManifest({
          name: 'Nombre',
          short_name: 'Nombre corto',
          description: 'Tu propia descripción',
          background_color: '#ffffff',
          theme_color: '#2196f3',
          crossorigin: 'use-credentials', //can be null, use-credentials or anonymous
          icons: [
            {
              src: path.resolve('src/assets/img/icon.png'),
              sizes: [96, 128, 192, 256, 384, 512] // multiple sizes
            },
            {
              src: path.resolve('src/assets/img/icon.png'),
              size: '1024x1024' // you can also use the specifications pattern
            },
            {
              src: path.resolve('src/assets/img/icon.png'),
              size: '1024x1024',
              purpose: 'maskable'
            }
          ]
        }),
]
```

Lo anterior creará un archivo manifest en la misma carpeta de salida del
bundle que se genera con webpack.

### 1.14.1 Soporte offline como PWA

Para crear soporte como PWA google nos ofrece una aplicación llamada
workbox-webpack-plugin

``` javascript
npm i workbox-webpack-plugin --save-dev
```

Ahora lo requerimos en el archivo de *webpack.config.js*

``` javascript
const WorkboxWebpackPlugin = require('workbox-webpack-plugin')
```

Ahora en la sección de plugins colocamos una serie de caches donde cada
uno parte de una expresión regular.

-   urlPattern: Se refiere al patrón de expresiones regulares que
    definiremos, sus reglas se definirán abajo.
-   cacheName: Indica al nombre de la cache.
-   CacheFirst: Establece que se busque primero en la cache antes de
    intentar acceder a la red
-   NetworkFirst: Prioriza el acceso a la red para buscar información,
    esto con la finalidad de tener siempre datos actualizados.

``` javascript
new WorkboxWebpackPlugin.GenerateSW({
     swDest: 'service-worker.js',
     clientsClaim: true,
     skipWaiting: true,
     maximumFileSizeToCacheInBytes: 5000000,
     runtimeCaching: [
       {
         urlPattern: new RegExp(
           'https://(res.cloudinary.com|images.unsplash.com)'
         ),
         handler: 'CacheFirst',
         options: {
           cacheName: 'images'
         }
       },
       {
         urlPattern: new RegExp(
           'https://react-avanzado-testing-b39h5jmoy-eduardozepeda.vercel.app/'
         ),
         handler: 'NetworkFirst',
         options: {
           cacheName: 'api'
         }
       }
     ]
   })
```

A pesar de que la configuración ya está lista y que se está generando un
service-worker, necesitamos incluirlo en nuestro archivo html.

``` javascript
<script>
    if('serviceWorker' in navigator){
        window.addEventListener('load', function(){
            navigator.serviceWorker.register('/service-worker.js')
            .then(registration => {
                console.log('SW registrado')
            })
            .catch(registrationError => {
                console.log('SW no registrado')
            })
        })
    }
</script>
```

Recuerda que cualquier cambio en la configuración de webpack requiere el
reinicio del server.

## 1.15 Testing con cypress

``` javascript
npm i cypress --save-dev
```

Ahora agregamos un comando nuevo a *package.json*

``` javascript
"scripts": {
    "test": "cypress open"
}
```

Se creara una carpeta llamada cypress, dentro de la cual habrá una
carpeta llamada integration que es donde pondremos nuestras pruebas.

``` javascript
//cypress/integration/nuestro_projecto/test_specs.js

describe('Mi primer test', function(){
    it('para ver si funciona', function(){
        expect(true).to.equal(true)
    })
})
```

Al ejecutar nuestro comando test se nos abrirá una GUI desde donde
seleccionaremos el archivo que querramos ejecutar. Basta darle click
para que se ejecuten las pruebas.

``` javascript
npm run test
```

### 1.15.1 Configurar cypress

Al momento de ejecutar las pruebas se crea un archivo llamado
cypress.json, dentro de la raiz del directorio. En este archivo podremos
especificar una serie de parámetros para facilitar nuestras pruebas.

``` javascript
{
    "baseUrl": "https://react-avanzado-testing-eduardozepeda.vercel.app/", 
    "chromeWebSecurity": false,
    "viewportWidth": 500,
    "viewportHeight": 800
}
```

### 1.15.2 Pruebas

El objeto cy nos dotará de una serie de métodos que nos ayudarán a
visitar sitios y scrapear el DOM

``` javascript
it('Prueba si tras visitar el primer enlace de la navbar nos redirige al home de la app', function(){
    cy.visit('/objecto/1') // visita una página
    cy.get('nav a').first().click() // Clickea en el primer anchor de la navbar
    cy.url().should('eq', Cypress.config().baseUrl) // Revisa si ahora la url es /
})
it('Prueba si la ruta favs muestra dos formularios', function() {
    cy.visit('/favs') //Visita la ruta /favs
    cy.get('form').should('have.length', 2) //Obten los elementos form del DOM y asegúrate de que sean 2
})
```
