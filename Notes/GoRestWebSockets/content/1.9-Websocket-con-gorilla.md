## 1.9 Websocket con gorilla

Desde finales del 2022 Gorilla se ha puesto en modo lectura, por lo que es incierto si continuará siendo la biblioteca por defecto para el manejo de servidores web.

### 1.9.1 Manejo del hub

Para manejar las conexiones es buena idea crear un Hub, el cual contendrá el conjunto de conexiones (clientes) y se encargará de agregar nuevos y clientes y remover los viejos.

``` go
type Hub struct {
    clients    []*Client
    register   chan *Client
    unregister chan *Client
    mutex      *sync.Mutex
}
```

Y como constructor del Hub podemos usar

``` go
func NewHub() *Hub {
	return &Hub{
		clients:    make([]*Client, 0),
		register:   make(chan *Client),
		unregister: make(chan *Client),
		mutex:      &sync.Mutex{},
	}
}
```

#### 1.9.1.1 Manejo de conexiones y desconexiones en el hub

Con la función del hub podemos manejar conexiones y desconexiones, recuerda
que los clientes conectados se manejan en el struct Hub, por lo que, para evitar
condiciones de carrera, debe bloquearse con un mutex antes de realizar una
modificación.

``` go
func (hub *Hub) onConnect(client *Client) {
	log.Println("Client connected", client.socket.RemoteAddr())

	hub.mutex.Lock()
	defer hub.mutex.Unlock()
	client.id = client.socket.RemoteAddr().String()
	hub.clients = append(hub.clients, client)
}

func (hub *Hub) onDisconnect(client *Client) {
    client.socket.Close()
	client.Close()
	hub.mutex.Lock()
	defer hub.mutex.Unlock()

	i := -1
	for j, c := range hub.clients {
		if c.id == client.id {
			i = j
			break
		}
	}
	copy(hub.clients[i:], hub.clients[i+1:])
	hub.clients[len(hub.clients)-1] = nil
	hub.clients = hub.clients[:len(hub.clients)-1]
}
```

#### 1.9.1.2 Inicializar el Hub

Para arrancar el servicio del Hub, escuchando conexiones y desconexiones, manejamos un
bucle infinito.

``` go
func (hub *Hub) Run() {
    for {
        select {
        case client := <-hub.register:
            hub.onConnect(client)
        case client := <-hub.unregister:
            hub.onDisconnect(client)
        }
    }

}
```

#### 1.9.1.3 Inicializar la escucha de conexiones del hub

Ya con nuestra función Run definida, podemos correrla en la inicialización de
cualquier Server.

``` go
go app.Hub.Run()
```

## 1.9.2 Manejo del cliente

Cada cliente tendrá asignado un hub, una identificación y una conexión a un
websocket.

``` go
type Client struct {
    hub      *Hub
    id       string
    socket   *websocket.Conn
    outbound chan []byte
}
```

Y como constructor del cliente

``` go
func NewClient(hub *Hub, socket *websocket.Conn) *Client {
	return &Client{
		hub:      hub,
		socket:   socket,
		outbound: make(chan []byte),
	}
}
```

### 1.9.2.1 enviar mensajes a través del cliente

Para enviar mensajes usaremos el método WriteMessage, el cual podremos envolver en un bucle para que escuche constantemente a cualquier cambio en el canal outbund de nuestro cliente.

``` go
func (c *Client) Write() {
	for {
		select {
		case message, ok := <-c.outbound:
			if !ok {
				c.socket.WriteMessage(websocket.CloseMessage, []byte{})
				return
			}
			c.socket.WriteMessage(websocket.TextMessage, message)
		}
	}
}
```

#### 1.9.2.2 Cerrar una conexión

Para cerrar una conexión basta con llamar al método close del socket.

``` go
func (c Client) Close() {
	c.socket.Close()
	close(c.outbound)
}
```

### 1.9.3 Manejar la petición al websocket

#### 1.9.3.1 Upgrade de la conexión

Una conexión puede realizar un upgrade a una conexión de websocket, para
realizar un upgrade de la conexión modificamos la función *CheckOrigin* de la
propiedad *Upgrader*, que recibe el objeto *http.Request*.

``` go
var upgrader = websocket.Upgrader{
    CheckOrigin: func(r *http.Request) bool {
        // logica interna
        return true
    },
}
```

#### 1.9.3.2 Handler de manejo de websockets

Para manejar la conexión con el websocket la incluimos en un handler, este
handler se encargará de manejar las conexiones.

1. Primero llevamos a cabo un upgrade la conexión
2. A continuación creamos el nuevo cliente
3. Añadimos el nuevo cliente al registro
4. Escuchamos por nuevos mensajes a través del método Write de nuestro cliente

``` go
func (hub *Hub) HandleWebSocket(w http.ResponseWriter, r *http.Request) {
	socket, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		http.Error(w, "Error upgrading connection to web socket", http.StatusInternalServerError)
		return
	}
	client := NewClient(hub, socket)
	hub.register <- client

	go client.Write()
}
```

### 1.9.3.3 Añadir el handler al router

En el conjunto de rutas basta con agregar la función encargada del manejo de
websockets, HandleWebsocket.

``` go
r.HandleFunc("/ws", s.Hub().HandleWebsocket)
```

### 1.9.4 Broadcasting

Si queremos realizar un broadcasting a todos nuestros clientes basta con iterar por todo el Hub y enviar nuestro mensaje al canal outbound de cada cliente.

``` go
func (hub *Hub) Broadcast(message interface{}, ignore *Client) {
	data, _ := json.Marshal(message)
	for _, client := range hub.clients {
		if client != ignore {
			client.outbound <- data
		}
	}
}

```