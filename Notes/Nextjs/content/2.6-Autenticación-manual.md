## 1.6 Autenticación manual

Provider usa oauth por debajo para manejar la autenticación. Si
accedemos a la propiedad *Credentials* seremos nosotros quienes nos
encargaremos de la autenticación.

``` javascript
import Credentials from "next-auth/providers/credentials"

providers: [Credentials({
    name: 'Credentials',
    credentials: {
        password: {
            type: 'password',
            label: 'Nunca pares de...'
        }
    },
    async authorize(credentials, req) {
        const res = await fetch(`${process.env.NEXTAUTH_URL}/api/auth/credentials`, {
            method: 'POST',
            body: JSON.stringify(credentials),
            headers: new Headers({ 'content-type': 'application/json' })
        })
        const user = await res.json()
        if (res.ok && user) {
            return user
        }
        return null
    }
})]
```

### 1.6.1 Creando una pantalla de login

El campo credentials será un objeto con diferentes atributos html5, aqui
especificamos el password y el label. Nextjs se encargará de crear
automáticamente la página.

La configuración anterior creará una pantalla de loggeo de manera
automática en la ruta */api/auth/signin*

![image](Notes/Nextjs/img/NextjsAuthSignin.png)

### 1.6.2 Función authorize

La función authorize llamará al provider que especificamos y se ejecuta
cuando intentamos hacer un loggeo en la pantalla de login.

La función authoriza llamará a su método de autenticación, el cual debe retornar una respuesta
y, en caso de ser necesario, un objeto.

Dado que especificamos 'Credentials' como la propiedad name en el objeto
*providers* de *NextAuthOptions*, crearemos un archivo con el mismo
nombre dentro de *pages/api/auth/*, llamado Credentials.ts que contendrá la
función que usaremos para autentificar al usuario. En caso de que la
autenticación sea exitosa, retornaremos un usuario. 

``` javascript
const credentials: NextApiHandler<User> = async (request: NextApiRequest, response: NextApiResponse) => {
    const invalidCredentials = { "message": "invalid credentials" }
    // Only POST method is valid
    if (request.method !== 'POST') {
        response.status(405).end()
        return
    }
    try {
        const loginRequest = await fetch(loginUrl, {
            method: 'POST',
            body: JSON.stringify(request.body),
            headers: new Headers({ 'content-type': 'application/json' })
        })
        // Invalid credentials
        if (loginRequest.status !== 200) {
            //TODO Bug, always returns 200 see https://github.com/vercel/next.js/issues/46621
            response.json(invalidCredentials)
            response.status(loginRequest.status).end()
            return
        }
        // Valid credentials
        if (loginRequest.status === 200) {
            const { key } = await loginRequest.json()
            // If user managed to login in server, get its current data from this endpoint using newly adquired token
            const currentUser = await fetch(getCurrentUser, {
                method: 'GET',
                // This route is only for authenticated users, add token to headers
                headers: new Headers({ 'content-type': 'application/json', 'Authorization': `Token ${key}` },)
            })
            const userData = await currentUser.json()
            response.json({ ...userData, "token": key })
            response.status(200).end()
            return
        }
    } catch (err) {
        response.json(err);
        response.status(500).end();
    }
}

export default credentials
```

