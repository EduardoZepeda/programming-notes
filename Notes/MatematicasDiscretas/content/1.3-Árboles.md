## 1.3 Árboles

Los Árboles nos permiten organizar o estructurar información. Si tenemos
un nodo A y un nodo B, solo existirá una conexión entre ellos.

Los árboles son usados frecuentemente para expresar relaciones de
jerarquía.

Existen diferentes tipos de árboles:

### 1.3.1 Tipos de árboles

-   Libre: no es claro cual es el nodo principal o nodo raíz dentro de
    este árbol.
-   Raíz: se ve una estructura clara de los nodos. Todos parten de un
    mismo nodo.
-   Expansión: es similar al grafo empoderado, la conexión entre los
    nodos tiene un recurso asociado.
-   Binario: en cada uno de los niveles del árbol se tiene un máximo de
    dos conexiones.

Dentro de los árboles existe el nivel y la altura, los valores de estos
cambiaran dependiendo del nodo que tomes como raíz.

El nivel de un árbol es igual al máximo nivel posible de un nodo, el
nivel de un nodo se define por el número de conexiones entre el nodo y
la raíz más uno.

La altura de un árbol es igual al nivel del árbol más el nivel raíz.

### 1.3.2 Subárbol

Un subárbol es una parte de un árbol que hace parte de un árbol más
grande. Nos referimos a ellos como sub árbol raiz "b"

### 1.3.3 Vértice

Un vértice terminal es aquel nodo que ya no tiene más hijos o donde el
árbol ya no se expande. Por otro lado, los vértices internos son
aquellos que tienen hijos, ya sea uno o dos.

### 1.3.4 Árbol de expansión mínimo

Un árbol de expansión mínimo es aquel árbol que partiendo de una raíz
pueda conectar todos los vértices buscando los caminos de menor costo.
Para sacar el costo mínimo del árbol solo basta con ir sumando el valor
que tiene cada conexión nivel por nivel, luego sumar todos los niveles.

![image](Notes/MatematicasDiscretas/img/arbol_expansion_minima.png)

Hecho el árbol podriamos utilizar el vértice del costo mínimo como la
raiz del árbol.

![image](Notes/MatematicasDiscretas/img/arbol_expansion_minima_raiz_g.png)

### 1.3.5 Árbol binario

Un árbol binario es aquel donde tenemos un máximo de dos hijos por cada
uno de los vértices.

#### 1.3.5.1 Tipos

Existen dos tipos de arboles binarios:

-   Completo
-   Lleno

El primero de ellos es el árbol binario completo donde cada uno de los
vértices tiene sus dos ramas bien definidas o no tiene ninguna. El árbol
binario lleno es aquel donde todos los nodos llegan a un mismo punto y
al final todas sus ramas son terminales.

![image](Notes/MatematicasDiscretas/img/arbol_binario_tipos.png)

El árbol degenerado es donde la mayoría de sus nodos tienen solo un
hijo.

![image](Notes/MatematicasDiscretas/img/arbol_binario_degenerado.png)

#### 1.3.5.2 Recursividad

Un árbol binario es una estructura recursiva pues puede llamarse a si
misma, puedes descomponerlo en partes más pequeñas.

![image](Notes/MatematicasDiscretas/img/arbol_binario_recursivo.png)

#### 1.3.5.3 Recorrido de árboles

Al momento de representar un árbol debemos elegir el orden en el cual
vamos a recorrer dicho árbol. Dependiendo de qué orden se elija será la
forma en que se va a representar el árbol.

Existen tres formas de recorrer un árbol:

-   Pre orden: se inicia leyendo el nodo raíz, luego se pasa al hijo
    izquierdo y por ultimo al derecho.
-   In orden: inicia leyendo el hijo izquierdo, luego la raíz y por
    último el hijo derecho.
-   Pos orden: comienza por el hijo izquierdo para posteriormente ir al
    hijo derecho y por último al nodo raíz.

Cuando nos encontremos con que el hijo izquierdo o derecho son a su vez
un nodo raiz habrá que desarrolloarlos tomándolos a ellos mismos como la
raiz.

### 1.3.6 Expresiones aritméticas

Los árboles también nos sirven para representar expresiones aritméticas,
para ello debe cumplir con las siguientes condiciones:

-   Los vértices terminales son operandos.
-   Los vértices internos son operadores.
-   La raíz siempre debe ser un operador.

Así como vimos las diferentes formas para recorrer un árbol, las
expresiones aritméticas tienen también sus propias formas:

**Nota: El nombre indica la posición de la raiz; pre, para primera
posición; in, para posición media; pos, para posición final. Después se
escriben izquierda y derecha, siempre en ese orden.**

-   Pre fijo: raíz-izquierda-derecha
-   In fijo: izquierda-raíz-derecha
-   Pos fijo: izquierda-derecha-raíz

![image](Notes/MatematicasDiscretas/img/arbol_operaciones_aritmeticas.jpg)

### 1.3.7 Algoritmos

#### 1.3.7.1 Algoritmo de Prim

Encuentra el menor costo de recorrer todos los vértices de un árbol de
expansión.

1.  Escogemos un vértice al azar.
2.  Escogemos la arista con menor coste.
3.  Repetimos el paso 2, incluyendo las opciones del nuevo vértice.
4.  Evitar la creación de ciclos
5.  El algoritmo termina cuando hemos conectado todos los vértices con
    n-1 aristas, donde n es la cantidad de vértices.

#### 1.3.7.2 Algoritmo de Dijkstra

El algoritmo de Dijkstra va a buscar la ruta optima o de menor coste
entre dos vértices.

1.  Asignar el valor infinito a cada noto no visitado
2.  Mantener un registro de los nodos visitados
3.  Calcular la distancia a cada nuevo nodo sumando la distancia
    anterior
4.  Si la nueva distancia calculada es menor que la anterior, se debe
    reemplazar en el nodo, sino dejar la anterior
5.  Se finalizará cuando se llega al nodo final.

#### 1.3.7.3 Algoritmo de Kruskal

El algoritmo de Kruskal al igual que el algoritmo de Prim sirve para
buscar el árbol de expansión mínimo, la diferencia es que el algoritmo
de Kruskal inicia seleccionando la arista de menor valor y después en
cada iteración se agrega la arista de menor valor del conjunto
disponible.

1.  Seleccionar arista con menor coste, en caso de repetir no importa
    porque en el siguiente paso se elegirá.
2.  En cada iteracion agregar la arista de menor longitud del conjunto
    de arcos disponibles. **No aceptaremos ninguna arista que cause un
    bucle**
3.  El algoritmo finaliza cuando todos los vertices esten conectados con
    n-1 arcos.

#### 1.3.7.4 Algoritmo de Fleury

El algoritmo de Fleury va a encontrar un ciclo euleriano. Recordemos que
un ciclo euleriano es un ciclo donde inicias y terminas en el mismo
punto, pasando por todas las aristas una sola vez.

1.  Verificar grado del grafo para que sea un ciclo. (Todos los vértices
    deben ser pares)
2.  Realizar un circuito cerrado
3.  En cada nueva iteración realizar un nuevo camino cerrado o ciclo
    visitando aristas que no han sido visitadas. Por ejemplo: Ciclo 1:
    afgba Ciclo 2: gecg Reemplazamos g con el ciclo 2: af(gecg)ba Y así
    sucesivamente con el resto de los ciclos.
4.  Reemplazar cada nuevo circuito en el inicial hasta visitar todas las
    aristas.

Para corroborar, el número de veces que se visita cada vértice debe ser
la mitad de su grado. Exceptuando el nodo inicial y terminal, que son el
mismo.

#### 1.3.7.5 Algoritmo de flujo máximo

Encuentra el camino de un punto A a un punto B, en un **grafo
dirigido**, con la mayor cantidad de flujo.

1.  Establecer un grafo dirigido.
2.  Establecemos todos los vértices en 0
3.  Establecer caminos desde el punto A hasta el punto B.
4.  Encontramos la conexión con menor capacidad, pues ésta es quien le
    dice al camino la capacidad máxima.
5.  Hacemos esta iteración hasta que no hayan más caminos, ante una
    eleccion seleccionar el mayor flujo.
6.  De cada ruta obtenemos un flujo, sumando todos los flujos
    obtendremos el flujo máximo.
