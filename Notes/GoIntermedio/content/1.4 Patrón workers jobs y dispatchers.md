## 1.4 Patrón workers, jobs y dispatchers

### 1.4.1 Jobs

Un job representa una tarea a ser ejecutada. Posee un nombre, un tiempo
de duración entre jobs y un número.

``` go
type Job struct {
    Name   string        // nombre del job
    Delay  time.Duration // retraso entre cada job
    Number int           // número que se procesará 
}
```

### 1.4.2 Worker

Un worker representa la unidad que se va a encargar de obtener los jobs
del JobQueue y procesarlos usando su método Start. En el método Start se
ejecutará la función encargada de procesar los números, en este caso
fibonacci

``` go
type Worker struct {
    Id         int           
    JobQueue   chan Job      // Jobs a procesar
    WorkerPool chan chan Job // Pool de workers (canal de canales de Job)
    Quit       chan bool     // Finalizar worker
}
```

### 1.4.3 Dispatcher

El dispatcher se encarga de asignar jobs a los workers.

``` go
type Dispatcher struct {
    WorkerPool chan chan Job // Pool de workers
    MaxWorkers int           // Máximo número de workers
    JobQueue   chan Job      // Trabajos a ser procesados
}
```

### 1.4.4 NewWorker

Crea un nuevo worker con id y su pool de workers.

``` go
func NewWorker(id int, workerPool chan chan Job) *Worker {
    return &Worker{
        Id:         id,
        WorkerPool: workerPool, // workerPool al que pertenece
        JobQueue:   make(chan Job),  // Crea una cola de jobs
        Quit:       make(chan bool), // Channel para finalizar los jobs
    }
}
```

### 1.4.5 Método Start del Worker

Comienza la ejecución de los workers.

``` go
func (w Worker) Start() {
    go func() {
        for {
            w.WorkerPool <- w.JobQueue // Agregar un Job de la cola de Jobs al pool de workers

            // Multiplexing
            select {
            case job := <-w.JobQueue: // Sacar un Job de la cola
                fmt.Printf("worker%d: started %s, %d\n", w.Id, job.Name, job.Number)
                fib := Fibonacci(job.Number) // Le pasamos la propiedad Number a la función que procesará nuestros datos
                time.Sleep(job.Delay) // Dormimos el retraso especificado por cada job
                // Imprimimos el valor fib que obtuvimos
                fmt.Printf("worker%d: finished %s, %d with result %d\n", w.Id, job.Name, job.Number, fib)
            case <-w.Quit: // Si el worker tiene quit, lo finalizamos.
                fmt.Printf("Worker with id %d Stopped\n", w.Id)
                return
            }
        }
    }()
}
```

### 1.4.6 Método Stop del worker

Cambia la propiedad Quit del worker.

``` go
func (w Worker) Stop() {
    go func() {
        w.Quit <- true
    }()
}
```

### 1.4.7 Creador del dispatch

Crea un nuevo dispatcher con los argumentos que le pasamos.

``` go
func NewDispatcher(jobQueue chan Job, maxWorkers int) *Dispatcher {
    workerPool := make(chan chan Job, maxWorkers) // Hacemos un pool de workers.
    return &Dispatcher{
        WorkerPool: workerPool,
        MaxWorkers: maxWorkers,
        JobQueue:   jobQueue,
    }
}
```

### 1.4.8 Método dispatch del Dispatcher

El método dispatch creará un loop infinito, en el cual escuchará por
objetos de la cola de Jobs y los asignará a un worker

``` go
func (d *Dispatcher) dispatch() {
    for {
        select {
        case job := <-d.JobQueue: // Obtén un job de la cola de Jobs del dispatcher
            // Asigna el Job a un worker
            go func() {
                jobChannel := <-d.WorkerPool // Obten un jobChannel del Worker Pool
                jobChannel <- job // Pasale el job a ese jobChannel 
            }()
        }
    }
}
```

### 1.4.9 Método run del dispatch

Crea un worker hasta que alcancemos el máximo número de workers y
córrelo.

``` go
func (d *Dispatcher) Run() {
    for i := 0; i < d.MaxWorkers; i++ {
        worker := NewWorker(i+1, d.WorkerPool) //Asignalo al workerPool del dispatcher
        worker.Start() // Haz que el worker procese los jobs pendientes
    }

    go d.dispatch()
}
```

