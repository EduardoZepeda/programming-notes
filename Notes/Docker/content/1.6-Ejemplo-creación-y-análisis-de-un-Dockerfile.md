## 1.6 Ejemplo, creación y análisis de un Dockerfile

Con todos estos archivos vamos a crear una imagen personalizada para
nuestro Dockerfile. Abre el archivo Dockerfile con tu editor de texto
favorito y vamos a escribir el siguiente contenido.

``` bash
FROM python:3.6
ENV PYTHONUNBUFFERED 1

ADD . /app/

WORKDIR /app/myDockerDjangoApp

RUN pip install -r /app/requirements.txt

EXPOSE 8000
ENV PORT 8000

CMD ["gunicorn", "myDockerDjangoApp.wsgi"]
```

-   FROM python:3.6: Todos los Dockerfile necesitan una imagen de la
    cual partir, en este caso esa imagen es python:3.6
-   ENV PYTHONBUFFERED 1: Permite que podamos leer los logs de Python en
    nuestra terminal
-   ADD . /app/: Agrega todos nuestros archivos en la carpeta actual a
    la carpeta /app/. También sirve COPY, la diferencia radica en que
    APP acepta archivos comprimidos o una url.
-   WORKDIR /app/myDockerDjangoApp: Establece la carpeta
    /app/myDockerDjangoApp como la carpeta base a usar al correr
    comandos con CMD, RUN, ADD o COPY
-   RUN pip install -r /app/requirements.txt: RUN permite ejecutar
    comandos, los cuales se ejecutan al momento de compilar la imagen y
    quedan grabados como una capa nueva en la imagen. Usaremos RUN para
    instalar todas las dependencias que especificamos en el archivo
    requirments.txt (solo Django y Gunicorn).
-   EXPOSE 8000: Expone el puerto 8000 al exterior.
-   ENV PORT 8000: Crea una variable de entorno llamada PORT con el
    valor de 8000. Esto nos servirá para poder acceder al puerto.
-   CMD \[«gunicorn», «myDockerDjangoApp.wsgi»\]: CMD ejecuta un comando
    al momento de poner en marcha un contenedor a partir de una imagen,
    los comandos y los argumentos se separan como si fueran una lista de
    Python. En este caso, como mencioné arriba, gunicorn solo necesita
    saber donde está el archivo wsgi que generó django automáticamente.

### 1.6.1 El orden es importante en un Dockerfile

La compilación de un Dockerfile es un proceso secuencial, cada paso crea
una imagen intermediaria que Docker puede guardar en cache. Docker usa
esa cache para evitar tener que repetir pasos innecesarios cuando ocurre
un cambio en un Dockerfile, es decir que si tú realizas un cambio en uno
de los pasos, Docker tratará de usar sus datos en cache para no repetir
todos los pasos anteriores. Ten en cuenta el orden en el que realizas
tus instrucciones para evitarte compilaciones de imágenes costosas en
tiempo y recursos.

``` bash
Sending build context to Docker daemon   12.8kB
Step 1/8 : FROM python:3.6
 ---> 46ff56815c7c
Step 2/8 : ENV PYTHONUNBUFFERED 1
 ---> Using cache
 ---> c55438b3c6a0
Step 3/8 : ADD . /app/
 ---> Using cache
 ---> ecedebf26f36
Step 4/8 : WORKDIR /app/myDockerDjangoApp
 ---> Using cache
 ---> 83b5ccaa1cc6
Step 5/8 : RUN pip install -r /app/requirements.txt
 ---> Using cache
 ---> 6cb2683c8fa8
Step 6/8 : EXPOSE 8000
 ---> Using cache
 ---> 744b46577c43
Step 7/8 : ENV PORT 8000
 ---> Using cache
 ---> 03111761fb54
Step 8/8 : CMD ["gunicorn", "myDockerDjangoApp.wsgi"]
 ---> Using cache
 ---> 6e3ffe358338
Successfully built 6e3ffe358338
Successfully tagged djangocontainer:0.1
```

### 1.6.2 Compilación de un Dockerfile

Para compilar un Dockerfile y crear una imagen personalizada creada a
partir del contenido de nuestro archivo, basta con ejecutar el comando
docker build y establecer la localización del Dockerfile. Docker build
nos permite especificar un tagname y una versión, separados por dos
puntos «:», usando la etiqueta –tag. Nota que el punto de al final no es
una mancha en tu pantalla o un error, sino que hace referencia a la
carpeta en la que nos encontramos.

``` bash
docker build --tag djangocontainer:0.1 .
```

Puedes ver que nuestra imagen ha sido creada ejecutando el comando
docker images

``` bash
docker images
REPOSITORY                                      TAG                 IMAGE ID            CREATED              SIZE
djangocontainer                                 0.1                 6e3ffe358338        About a minute ago   912MB
```

Ahora que ya contamos con la imagen basta con ejecutarla. Para este
ejemplo vincularemos nuestro puerto 8000 con el puerto 8000 de nuestro
contenedor, ejecutaremos nuestro contenedor en segundo plano y lo
nombraremos test_container.

``` bash
docker run -p 8000:8000 -d --name test_container djangocontainer:0.1
```

Si abrimos nuestro navegador y entramos a nuestro localhost en el puerto
8000 veremos el cohete de Django indicando que todo funcionó
perfectamente. Gunicorn está sirviendo nuestra aplicación de Django en
el puerto 8000, al que podemos acceder a través de nuestro puerto del
mismo número.

``` bash
docker run -p 8000:8000 -d --name test_container djangocontainer:0.1
```

