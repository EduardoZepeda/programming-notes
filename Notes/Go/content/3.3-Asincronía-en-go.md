## 1.3 Asincronía en go

### 1.3.1 Unbuffered channels y buffered channels

Es un canal sin una capacidad máxima definida. Un canal sin buffer
transmite un mensaje en cuanto lo recibe. Tenemos que estar seguros de
que hay una función lista para recibir los datos del canal.

``` go
// no se imprime el 1 
// Error: fatal error: all goroutines are asleep - deadlock!
c := make(chan int)
c <- 1
fmt.Println(<-c)
```

Un buffered channel es una cola que cuenta con una cantidad fija de
espacios, sirve para imitar la cantidad de GoRoutines siendo ejecutadas.
Mientras que un canal con buffer recibe su capacidad total y no se
bloquea esperando la función.

``` go
// Se imprime el 1
c := make(chan int 3)
c <- 1
fmt.Println(<-c)
```

### 1.3.2 Waitgroups

Los Waitgroups sirven para sincronizar las goroutines.

Podemos crear un grupo de espera a través del paquete sync

``` go
var wg sync.WaitGroup
```

<div class="warning">

<div class="title">

Warning

</div>

Los valores de wg como argumento a funciones deben pasarse por
referencia.

</div>

``` go
var wg sync.WaitGroup
myFuncion(&go)
func(wg *sync.WaiGroup)
```

Con el método Add podemos añadir un contador al WaitGroup

``` go
wg.Add(1)
```

Para remover un contador usamos el método Done

``` go
wg.Done()
```

El método wg.Wait detendrá la ejecución del código hasta que no haya más
contadores.

``` go
wg.Wait()
```

### 1.3.3 canales de lectura y escritura

Canal de solo escritura: Flecha \<- a la derecha de chan. Como si
entrara en el canal

``` go
func Generator(c chan<- int)
```

Canal de solo lectura: Flecha \<- a la izquierda de chan como si saliera
del canal.

``` go
func Print(c <-chan int)
```

### 1.3.4 Worker pools

Es un modelo que permite que un conjunto de workers, implementados con
goroutines, efectuen tareas en una cola de tareas, implementada con
channels.

``` go
func Worker(id int, jobs <-chan int, results chan<- int) {
    for j := range jobs {
        fmt.Println("worker", id, "started  job", j)
        fib := Fibonacci(j)
        results <- fib
        fmt.Println("worker", id, "finished job", j, "result", fib)
    }
}
```

Primero definimos las tareas a ejecutar, creamos los canales.

``` go
// numeros de fibonacci 
tasks := []int{2, 3, 4, 5, 7, 10, 12, 35, 37, 40, 41, 42}

// tareas
nWorkers := 3
jobs := make(chan int, len(tasks))
results := make(chan int, len(tasks))
```

Inicializamos los workers

``` go
for w := 1; w <= nWorkers; w++ {
    go Worker(w, jobs, results)
}
```

Les asignamos las tareas

``` go
// give the workers jobs
for _, t := range tasks {
    jobs <- t
}
close(jobs)
```

### 1.3.5 Multiplexación

Se usa la palabra reservada select y case en conjunto para identificar
canales y actuar en consecuencia.

``` go
select {
        case res := <-c1:
            fmt.Println("Received", res, "from c1")
        case res := <-c2:
            fmt.Println("Received", res, "from c2")
        }
    }
```

